# while文
while &nbsp;繰り返し続ける条件 &nbsp;do\
  &emsp;繰り返したい処理\
end

```Ruby
i = 10
while i <= 10 
  puts i
  i = i + 1
end
```

# timesメソッド
繰り返す回数.times &nbsp;do\
  &emsp;繰り返したい回数\
end

繰り返しの回数が決まっている時は、「timesメソッド」を使うとシンプルにできる！\
「do」は省略できない。

「All work and no play makes Jack a dull boy.」と100行表示する
```Ruby
100.times do
putst "All work and no play makes Jack a dull boy."
```

# 配列・ハッシュ※オブジェクトを格納するオブジェクトをコンテナやコレクションという
配列オブジェクト（Arrayオブジェクト）
```Ruby
names = ["小林","林","高野","森岡"]
names = []
```
配列オブジェクトが作られた。各要素として「小林」「林」「高野」「森岡」がある
配列の要素が決まってないない場合には[]とだけ書く

配列の取り出し

```Ruby
names = ["小林","林","高野","森岡"]
puts "最初の名前は",names[0],"です。"
最初の名前は小林です。
```
配列にオブジェクトを格納する
構文：配列名[インデックス] = 格納したいオブジェクト

```Ruby
names = ["小林","林","高野","森岡"]
names[0] = "野尻"
```

配列の大きさを得る
sizeメソッドを使う
array.size

```Ruby
names.size
```

配列と繰り返し

eachメソッド※イテレータというメソッドの一つ
end~doで囲まれている部分をブロックという。故にブロックつきメソッドとも呼ばれる

構文

配列.each do |変数|
  繰り返したい処理
end

ハッシュ（Hash）
ハッシュでは文字列やシンボルキーなどをキーにしてオブジェクトを格納する
シンボルは文字列に似たオブジェクト。
シンボル（:文字列）

address = {name: "高橋",furigana: "タカハシ",postal: "1234567"}

シンボルをキーにする場合、２通りの書き方ができる
「シンボル => オブジェクト」
「シンボル名 => オブジェクト」

person1 = {:name => "後藤", :furigana => "ゴトウ"}
person2 = {name: "後藤", furigana: "ゴトウ"}

ハッシュの操作
ハッシュ名[キー]
ハッシュ名[キー] = 格納したいオブジェクト

# コマンドラインからのデータの入力

コマンドラインの情報をデータとして受け取る「ARGV」という配列オブジェクトを使う。
※簡単に言うと、コマンドラインの引数を受け取ってくれる。

```Ruby
sample.rb
puts "最初に引数: #{ARVG[0]}"
puts "最初に引数: #{ARVG[1]}"
puts "最初に引数: #{ARVG[2]}"
puts "最初に引数: #{ARVG[3]}"
puts "最初に引数: #{ARVG[4]}"

ruby sample.rb 1th 2nd 3rd 4th 5th
=>最初の引数: 1th
=>最初の引数: 2nd
=>最初の引数: 3rd
=>最初の引数: 4th
=>最初の引数: 5th

```

# ファイルからテキストデータを読み込んで表示する
①ファイルを開く
②ファイルのテキストデータを読み込む
③読み込んだテキストデータを出力する
④ファイルを閉じる

コマンドラインの引数をファイルに指定し、ファイルの内容を読み込んで表示する
```Ruby
filename = ARGV[0]
file = File.open(filename)
text = file.read
print text
file.close 
```

```Ruby
filename = ARGV[0]
file = File.open(filename)
file.each_line do |line|
  print line
end
file.close
```

```Ruby
pattern = Regexp.new(ARGV[0])
filename = ARGV[1]

file = File.open(filename)
file.each_line do |line|
  if pattern =~ line
    print line
  end
end
file.close
```

# メソッドの作成

def メソッド名
  メソッドで実行したい処理
end

```Ruby
def hello
  puts "Hello, Ruby."
end

hello()
```

# 別のファイルを取り込む

プログラムの中でライブラリを読み込む

require　使いたいライブラリのファイル名

require_relative　使いたいライブラリのファイル名

使いたいライブラリのファイル名の[.rb]は省略することができる

# requireメソッド

```Ruby
require "data"

days = Date.today - Date.new(1993, 2, 24)
puts days.to_i

```

requireメソッドでdateライブラリを読み込むことで、今日の日付を求めるDateメソッドなどを利用できる。

# Rubyでデータを扱うための基礎

①オブジェクト

②クラス

③変数

④定数

# ①オブジェクト

数値オブジェクト：数を表すオブジェクト。

文字列オブジェクト：文字の並びのオブジェクト

配列オブジェクト、ハッシュオブジェクト：複数のデータをまとめるためのオブジェクト

正規表現オブジェクト：マッチングのためのパターンを表すオブジェクト

時刻オブジェクト：時刻を表すオブジェクト

ファイルオブジェクト：ファイルへの読み書きを行うためのオブジェクト

シンボルオブジェクト：Rubyがメソッドなどの名前の識別に使うラベルを表すオブジェクト

※「範囲オブジェクト」「例外オブジェクト」などがある。

# ②クラス

クラスとはオブジェクトの種類を表すもの。

オブジェクトがどのような性質も持つのかは、オブジェクトが属するクラスによって決められる。

数値オブジェクト：Numericクラス

文字列オブジェクト：Stringクラス

配列オブジェクト：Arrayクラス

ハッシュオブジェクト：Hashクラス

正規表現オブジェクト：Regexp

ファイルオブジェクト：Fileクラス

シンボルオブジェクト：symbolクラス

※自分で新しいクラスを定義することもできる

# 変数

変数とはオブジェクトにつける名札のようなもの。

ローカル変数：先頭がアルファベットの小文字か「_」で始まる。

グローバル変数：先頭が「$」で始まる。

インスタンス変数：先頭が「@」で始まる。

クラス変数：先頭が「@@」で始まる。

疑似変数：「nil」「true」「false」「self」など特定の値を指し示すため予約された名前。代入することによって値を変更できない。

# 定数

定数とは変数と同様に、あるオブジェクトにつける「名札」の働きをする。

しかし、変数と違って、一度代入したあとでもう一度同じ定数に代入すると警告される。

先頭がアルファベット大文字で始まる。

Rubyで予め定義されている定数があ利、「組み込み定数」と呼ばれる。

# 予約語

使用が制限されている名前。

# 多重代入

複数の変数への代入を1つの式で一度に行うこともできる。この機能を多重代入と言う。

```Ruby
first = 1
second = 2
third = 3

first,second,third = 1,2,3

```

まとめるのは関係のある変数にすると良い。

受け取る側の変数に1つだけ「※」をつけておくと、その変数には余った値の配列が代入される。

```Ruby
first,second,*rest = 1,2,3,4,5
p [first,second,*rest]  #=> [1,2,[3,4,5]]
```

変数の値を入れ替える

```Ruby
a,b = 0,1
a,b = b,a
p [a,b] #=> [1,0]
```

配列の要素を取り出す

配列を代入するときに左辺に複数の変数があると、自動的に配列の要素を取り出して多重代入が行われる。

```Ruby
ary = [0,1]
a,b = ary
puts a #=> 0
puts b #=> 1
```

配列の先頭の要素だけを取り出したい場合には、次のように書く。

```Ruby
ary = [1,2]
a, = ary
puts a #=> 1

# a,_ = aryでもok
# _はダミーの変数
```

# 条件判断

Rubyの真偽値

真：falseとnilを除くオブジェクト全て
偽：falseとnil

真偽値を表すメソッドの名前は、一目でわかるように末尾に「？」をつけると言うルールがある。

自分でメソッドを作る場合は、このルールに合わせるのが良い。

```Ruby
p "".empty? #=>true
p "AAA"empty? #=>false
```

```Ruby
p /Ruby/ =~ "Ruby" #=> 0
p /Ruby/ =~ "Diamond" #=> nil
```

論理演算子

「&&」「||」は条件を一つにまとめる時に使います。

条件1 && 条件2

条件1と条件2がどちらも「真」である場合に、全体も「真」となる。

どちらか一方でも「偽」であった場合は、全体も「偽」となる。

条件1 || 条件2

条件1と条件2のいずれか一方が「真」なら、全体も「真」になる。

!条件

条件の反転を意味する。

条件が「偽」である場合は、「真」に、「真」である場合は、「偽」になる。

# if文

if 条件式 then
  文
end

※thenは省略可能

if 条件1 then
  文1
elsif 条件2 then
  文2
elsif 条件3 then
  文3
else
  文4
end

# unless文

if文とちょうど反対の役割をする条件判断文。

unless 条件 then
  文
end

※thenは省略可能。

if文の入れ替えである

unless 条件
  文1
else
  文2
end

これは下記と同じ

if 条件
  文2
else
  文1
end

# case文

比較したいオブジェクトが1つだけで、そのオブジェクトの値によって場合分けをしたい場合、case文を使った方がシンプルでわかりやすい。

case 比較したいオブジェクト
when 値1 then
  文1
when 値2 then
  文2
when 値3then
  文3
else
  文4
end

# まとめ

真偽値

真偽値とは条件を表す値で、

・nilかfalseのときは偽

・それ以外の値のときは真

条件判断文

条件判断文には、次の3つがあります。

・if文

・unless文

・case文

比較

if文、unless文の比較には、比較演算子(==,!=,<,>)、末尾に「?」がついたメソッド、論理演算子などで使う。

if文、case文

条件判断を行う為の基本的な構文です。

case文

「あるオブジェクトの状態によって様々に処理を変えたい」という「場合分け」の処理を書く為に使う。

# 繰り返し

繰り返しの基本

①繰り返したいことは何か
②繰り返しを止める条件は何か

# 繰り返しの実現方法

①繰り返しのための構文を利用する方法
②メソッドで実現する方法

メソッドにブロックを渡して、そのブロックの中に繰り返したい内容を書くことができる。

これは、繰り返しのための構文を使う場合と比べると、何らかの限定された目的に特化されている傾向がある。

繰り返しのための構文とメソッド
timesメソッド
for文
while文
until文
each文
loop文

# timesメソッド

「単純に一定の回数だけ同じ処理をさせる」という繰り返しに便利。

```Ruby

7.times do
  purs "いちめんのなのはな"
end
```

繰り返したい回数.times do
  繰り返したい処理
end

繰り返したい回数.times {
  繰り返したい処理
}

timesメソッドでは、ブロックの中で繰り返している回数を知ることもできる。

```Ruby
5.times do |i|
  puts "#{i}回目の繰り返しです。"
end
```

# for文

forはメソッドではない。

そういう文法の形式があると覚えること。

for 変数 in 開始時の処理..終了時の処理 do
  繰り返したい処理
end

```Ruby
sum = 0
for in in 1..5
  sum = sum + i
end
puts sum
```

for文は、timesメソッドと違い、開始時の値や終了時の値を自由に変更できる。

変数fromからtoまでの合計を計算する。

一般的なfor文

for 変数 in オブジェクト do
  繰り返したい処理
end

「..」「...」は実は"範囲オブジェクト"であり、厳密には一般的な構文にのっとって式を書いていた。

```Ruby
names = ["awk","Perl","Python","Ruby"]
for name in names
  puts name
end
```

# while文

while文は、どんなタイプの繰り返しにでも使える、単純な構文。

while 条件 do
  繰り返したい処理
end

これは、この条件が成り立っている間、繰り返したい処理が繰り返し実行される、という意味になる。

```Ruby
i = 1
while i < 3 
  puts i
  i += 1
end
```

```Ruby
sum = 0
i = 1
while sum < 50
  sum += i
  i += 1
end
puts sum
```

# until文

until文は、条件の判定がwhile文と反対になる。

つまり、その条件を満たしていない場合に繰り返しを行う。

while文は条件が成立している間繰り返すが、unless文は条件が成立するまで繰り返す。

until 条件 do
  繰り返したい処理
end

```Ruby
sum = 0
i = 1
until sum >= 50
  sum += i
  i += 1
end
puts sum
```

# eachメソッド

eachメソッドは、オブジェクトの集まりに対して、それを1つずつ取り出す時に使う。

```Ruby
names = ["awk","Perl","Python","ruby"]
names.each do |name|
  puts name
end
```

＊for文の内部処理としてはeachメソッドが実行される特殊構文になっている。

したがってeachメソッドを呼び出すことができるオブジェクトであれば、for文のinの後に指定することがきる。

# loopメソッド

終了条件がない、ただの繰り返しのためのメソッド。

```Ruby
loop do
  print "Ruby"
end
```

# 繰り返しの制御

break：繰り返しを中断し、繰り返しの中から抜ける
next：次の回の繰り返しに処理を移す
redo：同じ条件で繰り返しをやり直す

```Ruby
puts "breakの例："
i = 0
["Perl","Python","Ruby","Scheme"].each do |lang|
  i += 1
  if i == 3
    break
  end
  p [1,lang]
end
```

```Ruby
puts "nextの例："
i = 0
["Perl","Python","Ruby","Scheme"].each do |lang|
  i += 1
  if i == 3
    next
  end
  p [1,lang]
end
```

# 繰り返しのための構文とメソッドの主な用途

timesメソッド：回数の指定された繰り返し
for文：オブジェクトから要素を取り出す場合（eachのシンタックスシュガー）
while文：条件を自由に指定した場合
until文：whileではわかりにくい条件を指定したい場合
eachメソッド：オブジェクトから要素を取り出す場合
loopメソッド：回数制限のない繰り返し

# メソッドの呼び出し

①単純なメソッドの呼び出し

オブジェクト.メソッド名（引数1,引数2,...,引数n）

「オブジェクト」は、レシーバーとも呼ばれる。

オブジェクト指向の世界では、メソッドを実行することを「オブジェクトにメッセージを送る」、

その結果として、「オブジェクトはメッセージを受け取る」と考える。

あるオブジェクトに対して、いくつかのパラメータとともにメッセージを送るというイメージ。

②ブロックつきメソッド呼び出し

オブジェクト.メソッド名（引数, ...） {|変数1,変数2,...|
  ブロックの内容
}

演算子の形式のメソッド呼び出し

obj + arg1
obj =~ arg1
-obj
!obj
obj[arg1]
obj[arg1] = arg2































































































































